## 0.00 Unity入门+实践 重点合并

我主要在这里留下了一些我自己学习上不懂的,来加强学习


重点错误:一个物体子物体有Rb和collider,它本身是一个空的gameobject,如果在它身上挂载脚本去检测是否和别的物体碰撞是不会触发的,这是为什么?
1. **碰撞检测的前提条件:**
    
    - 参与碰撞的两个物体必须都有Collider组件,且至少有一个物体还需要Rigidbody组件。
    - 如果父对象没有Collider和Rigidbody,即使子对象有,父对象上的脚本也无法检测到碰撞。
2. **空GameObject的作用和限制:**
    
    - 通常用于组织场景结构或作为子对象的容器。
    - 如果没有Collider或Rigidbody,它不会参与物理碰撞,无法触发碰撞事件。
3. **Transform的几个常用方法:**
    
    - TransformPoint考虑位置、旋转和缩放。
    - TransformDirection只考虑旋转。
    - TransformVector考虑旋转和缩放,不考虑位置。(**向量**：在游戏开发中，向量常用来表示方向和距离，但不具有具体位置。)

```cs
Transform child = transform.Find("Parent/Child");
//`Transform.Find` 方法可以通过路径查找子对象或子对象的子对象。路径中的斜杠 `/` 用于区分父子关系。
```
**四元数 vs 欧拉角**：`transform.rotation` 使用四元数表示旋转，虽然计算精确，但不直观。`transform.eulerAngles` 使用更易理解的三维向量表示旋转角度，适合直接操作。
#### 2. 单例模式的使用

**单例模式的正确用法**：

- 单例模式通常在 `Awake` 方法中初始化 `Instance`，确保在使用类名加 `Instance` 访问时，单例已经正确初始化。

**常见问题**：

- 如果在 `Awake` 中未初始化 `Instance`，将导致在其他地方使用 `类名.Instance` 时出现 `null` 引用，无法正确访问单例对象。

**泛型约束**：

- 如果使用泛型单例模式，需要对泛型参数进行约束，例如限定为某个基类或接口。确保泛型类型在单例中能够被正确使用。

```cs
public class Singleton<T> : MonoBehaviour where T : class
{
    public static T Instance { get; private set; }

    protected virtual void Awake()
    {
        Instance = this as T;
    }
}

```


你要有Collider或者是trigger,可以没有**rigidbody**,挂载脚本,就能响应OnCollider/OnTrigger
重点:如果是Rigidbody里面的子物体有脚本来检测是否碰撞,是不会**触发**的

#### 3. 物体移动和力的应用

**重要概念**：

- **AddForce**：通过 `AddForce` 给物体施加力，使其沿指定方向移动。适用于模拟物理效果的场景。
- **改变 Position/Translate**：直接设置物体的位置，用于不需要物理模拟的情况。
- **爆炸力 (`AddExplosionForce`)**：针对单个 `Rigidbody` 使用，施加爆炸效果，力的作用受物体质量、阻尼等物理属性影响。



- **不要在`Awake`中调用依赖于其他对象或组件状态的方法**，以确保初始化顺序的正确性。
- **所有状态在`Start`时都应该是安全和稳定的**，以便你可以在`Start`中安全地进行依赖于其他组件的初始化。
- **检查所有在`Start`中初始化的变量**，确保它们不会在不合适的时机被访问。

#### 4.**项目实践中的一些总结:**
    
    - 尽量精简UI标签,可以把多个同类型的数据放在一个标签下处理。
    - 注意在Awake中绑定必要的组件引用,否则可能出现空引用错误。
    - 理解GameDataManager的使用,注意它没有继承MonoBehaviour。
    - List可以直接移除指定索引之后的所有元素,不需要遍历。
    - 单例模式下切换场景时instance的重新指向。
    - 跟随目标移动可以直接用偏移量,而不是用坐标相减的方式。
-  **武器实例化的代码改进:**
    
    - 确保currentWeapon引用的是Instantiate生成的对象,而不是预制体。
    - 保证生成的武器位置和旋转与挂载点weaponPoint对齐。
    - 对currentWeapon的操作将作用于正确的实例化武器对象。
-  **场景切换与单例模式的问题**
    
    - 在切换场景时，如果 `SettingPanel` 使用单例模式，新的场景中会生成一个新的 `SettingPanel` 实例。在这个过程中，新的 `SettingPanel` 会在其 `Awake()` 方法中将单例 `Instance` 重新指向自己，导致先前场景中的 `Instance` 被覆盖。
    - 每次场景切换，新的 `SettingPanel` 会覆盖原有的单例实例，这可能会导致引用不一致，尤其是在 `GameDataManager` 或其他管理器中需要访问该 `SettingPanel` 时。
    - 可以在 `Awake()` 中使用 `DontDestroyOnLoad`，并确保在新场景中不会再次生成 `SettingPanel` 的实例。
    - 
```cs
public class SettingPanel : MonoBehaviour
{
    public static SettingPanel Instance { get; private set; }

    protected virtual void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject); // 保留实例跨场景
        }
        else
        {
            Destroy(gameObject); // 如果已经有一个实例存在，销毁新的实例
        }
    }
}

```






``` csharp
public void SetWeapon(Weapon weapon)
{
    this.currentWeapon = weapon; //实际上这里是错误的使用,currentWeapon和下面的代码一点关系都没用
    Instantiate(weapon.gameObject, weaponPoint.position, weaponPoint.rotation, weaponPoint);
}

```
#### 关键改进点：

1. **正确引用实例化对象**：修改后的代码确保 `currentWeapon` 引用的是通过 `Instantiate` 生成的武器对象，而不是传入的预制体。
    
2. **保证位置和旋转正确**：通过实例化后再赋值给 `currentWeapon`，确保了该对象的位置和旋转与 `weaponPoint` 对齐。
    
3. **后续使用正确对象**：现在，任何对 `currentWeapon` 的操作（例如在 `Fire` 方法中）都会作用于正确的实例化武器对象，从而保证其行为符合预期。
    

#### 总结：

原代码的问题在于 `currentWeapon` 引用了预制体，而非实例化后的武器对象，导致位置和行为异常。通过将 `currentWeapon` 赋值为实例化后的武器对象，问题得以解决，确保了武器的位置和行为正确无误。
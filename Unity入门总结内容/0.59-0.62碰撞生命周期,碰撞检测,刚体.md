## 0.59-0.62碰撞生命周期,碰撞检测,刚体

你要有Collider或者是trigger,可以没有**rigidbody**,挂载脚本,就能响应OnCollider/OnTrigger
重点:如果是Rigidbody里面的子物体有脚本来检测是否碰撞,是不会**触发**的

![](Pictures/生命周期函数图.bmp)



`rb.AddExplosionForce` 是针对**单个物体上的 `Rigidbody`** 组件使用的，它将爆炸力作用于这个特定的物体。每个 `Rigidbody` 需要单独接受力的作用，因为每个物体可能会有不同的质量、阻尼等物理属性，这些属性会影响它们对力的响应。


### 动量定理基础

动量定理 F⋅t=m⋅vF \cdot t = m \cdot vF⋅t=m⋅v 描述了力的作用时间和物体质量与其速度变化之间的关系：

- **F**：力
- **t**：时间
- **m**：质量
- **v**：速度

### 力的应用方式

1. **添加力 (AddForce)**
    
    - **世界坐标系**：
        - 添加力使对象沿世界坐标系的Z轴正方向移动：`rigidBody.AddForce(Vector3.forward * 10);`
        - 使对象沿自己的前方移动：`rigidBody.AddForce(this.transform.forward * 10);`
    - **本地坐标系**：
        - 相对于自身坐标的前方移动：`rigidBody.AddRelativeForce(Vector3.forward * 10);`
    - **力的影响**：无阻力时，对象将持续移动。
2. **添加扭矩 (AddTorque)**
    
    - **世界坐标系**：使对象旋转：`rigidBody.AddTorque(Vector3.up * 10);`
    - **本地坐标系**：使对象相对于自身坐标旋转：`rigidBody.AddRelativeTorque(Vector3.up * 10);`
3. **直接改变速度**
    
    - 速度的方向相对于世界坐标系：`rigidBody.velocity = Vector3.forward * 5;`
4. **模拟爆炸效果**
    
    - 对所有影响范围内的对象应用爆炸力：`rigidBody.AddExplosionForce(100, Vector3.zero, 10);`

### 力的模式 (ForceMode)

1. **Acceleration**
    
    - 忽略物体质量，提供持续加速度：`rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration);`
2. **Force**
    
    - 考虑物体质量的持续力：`v = 10 * 0.02 / 2 = 0.1m/s` (物体质量为2kg)
3. **Impulse**
    
    - 瞬间力，考虑物体质量：`v = 10 * 1 / 2 = 5m/s` (物体质量为2kg)
4. **VelocityChange**
    
    - 瞬时速度变化，忽略质量和时间：`v = 10 * 1 / 1 = 10m/s`

### 动态计算示例

- 每物理帧的位移计算，例如，通过 `VelocityChange` 方式，速度为 `10m/s`，每帧 (0.02s) 的位移为：`0.2m`
- 

|参数|Acceleration|Force|Impulse|VelocityChange|
|---|---|---|---|---|
|公式|v = Ft/m|v = Ft/m|v = Ft/m|v = Ft/m|
|F (力)|(0,0,10)|(0,0,10)|(0,0,10)|(0,0,10)|
|t (时间)|0.02s (Unity物理帧更新时间)|0.02s (Unity物理帧更新时间)|默认为1s|默认为1s (对结果无影响)|
|m (质量)|默认为1|2kg|2kg|默认为1|
|v (速度)|0.2m/s|0.1m/s|5m/s|10m/s|
|每物理帧移动距离|0.004m|0.002m|0.1m|0.2m|
|特点|给物体增加一个持续的加速度,忽略其质量|给物体添加一个持续的力,与物体的质量有关|给物体添加一个瞬间的力冲量,与物体的质量有关|直接改变物体的速度,忽略质量和时间|
![](Pictures/Pasted%20image%2020240808103419.png)
